<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>飞机大战 · 终极Boss版（修复 + 贴图 + 音效 + 阶段弹幕）</title>
<style>
  :root{--ui:rgba(255,255,255,0.08);--ui-strong:rgba(255,255,255,0.14);--accent:#6ff}
  html,body{height:100%;margin:0;background:#000;touch-action:none;-webkit-user-select:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Microsoft YaHei',sans-serif}
  canvas{display:block;width:100vw;height:100vh}
  .joy-wrap{position:fixed;left:12px;bottom:12px;width:140px;height:140px;border-radius:999px;background:var(--ui);display:flex;align-items:center;justify-content:center;z-index:1000}
  .joy-base{position:relative;width:90%;height:90%;border-radius:999px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));}
  .joy-knob{position:absolute;width:46px;height:46px;border-radius:999px;background:linear-gradient(180deg,#08f,#0ff);box-shadow:0 6px 18px rgba(0,200,255,0.25);left:50%;top:50%;transform:translate(-50%,-50%)}
  .fire-btn{position:fixed;right:14px;bottom:18px;width:86px;height:86px;border-radius:999px;background:radial-gradient(circle,#ffec6a,#ff6a6a);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:22px;z-index:1000;box-shadow:0 12px 24px rgba(255,100,100,0.18)}
  .aux-row{position:fixed;right:14px;bottom:120px;display:flex;flex-direction:column;gap:10px;z-index:1000}
  .aux{width:72px;height:42px;background:var(--ui);border-radius:999px;display:flex;align-items:center;justify-content:center;font-weight:600}
  .hud{position:fixed;left:12px;top:12px;z-index:1000;display:flex;gap:12px}
  .badge{background:var(--ui);padding:8px 12px;border-radius:999px;color:#fff}
  .power-ind{position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:1000;color:#fff}
  .bossbar{position:fixed;left:50%;top:52px;transform:translateX(-50%);width:80%;height:16px;background:rgba(255,255,255,0.06);border-radius:10px;overflow:hidden;z-index:1000}
  .bossbar-inner{height:100%;background:linear-gradient(90deg,#ff4d4d,#ffb347);width:0%}
  .level-title{position:fixed;left:50%;top:38%;transform:translate(-50%,-50%);z-index:1001;padding:12px 20px;border-radius:12px;background:rgba(0,0,0,0.6);font-weight:800;letter-spacing:2px;display:none;color:#fff;font-size:18px}
  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;z-index:2000;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(0,0,0,0.9);color:#fff;padding:18px;border-radius:12px;min-width:260px;max-width:90%;text-align:center}
  .btn{display:inline-block;padding:10px 16px;border-radius:10px;background:var(--ui-strong);margin:8px 6px;color:#fff;font-weight:700;border:0;cursor:pointer}
  .hidden{display:none}
  .lb{max-height:60vh;overflow:auto;text-align:left}
  .lb-item{padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.03)}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="hud">
  <div class="badge" id="score">SCORE: 0</div>
  <div class="badge" id="lives">LIVES: 5</div>
  <div class="badge" id="levelBadge">LEVEL: 1</div>
</div>
<div class="power-ind" id="powerIndicator"></div>
<div class="bossbar" id="bossbar" style="display:none"><div class="bossbar-inner" id="bossbarInner"></div></div>
<div class="level-title" id="levelTitle">LEVEL 1</div>

<div class="joy-wrap" id="joyWrap"><div class="joy-base" id="joyBase"><div class="joy-knob" id="joyKnob"></div></div></div>
<div class="fire-btn" id="fireBtn">FIRE</div>
<div class="aux-row">
  <div class="aux" id="btnSpread">散弹</div>
  <div class="aux" id="btnMissile">镭射</div>
</div>

<!-- simple overlays (kept minimal) -->
<div class="overlay hidden" id="gameoverOverlay"><div class="panel"><h2>GAME OVER</h2><p id="finalScoreText">得分: 0</p><div><button class="btn" id="restartBtn">重开</button></div></div></div>
<div class="overlay hidden" id="victoryOverlay"><div class="panel"><h2>VICTORY</h2><p id="victoryScoreText">得分: 0</p><div><button class="btn" id="restartBtn2">再来一局</button></div></div></div>

<script>
/* ========== 飞机大战：稳定版（贴图/SVG-datauri、音效、Boss阶段、复杂弹幕、修复卡死） ========== */
/* 说明：
   - 将本文件保存为 UTF-8 (无 BOM)
   - 打开后在手机或桌面浏览器运行
   - 首次要触发一次屏幕交互（点击 FIRE）以解锁 AudioContext
*/

// -------- canvas init --------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth, H = canvas.height = innerHeight;
window.addEventListener('resize', ()=>{ W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

// -------- state --------
let score = 0, lives = 5, time = 0;
let level = 1; // 1..5
let boss = null;
let bossActive = false;   // 保护状态，避免重复触发
let isAdvancing = false;  // 保护 advanceLevel
let enemies = [], eBullets = [], particles = [], powerups = [], playerBullets = [];
let playing = true, gameOver = false, victory = false;
let shake = 0;

// -------- player --------
const player = { x: W/2, y: H*0.78, r: 28, speed: 520, hp: 3 };

// -------- power --------
let power = { mode:'single', timer:0, missileAmmo:0 };

// -------- joystick --------
const joyBase = document.getElementById('joyBase'), joyKnob = document.getElementById('joyKnob');
let joyActive = false, joyId = null, joyPos = {x:0,y:0}; const maxJoy = 46;
function joyToVector(){ return { x: joyPos.x / maxJoy, y: joyPos.y / maxJoy }; }
function updateKnob(){ joyKnob.style.transform = `translate(${joyPos.x}px, ${joyPos.y}px)`; }

// -------- sound (WebAudio) --------
let audioCtx = null;
function ensureAudio(){
  if(audioCtx) return;
  try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); startBGM(); }catch(e){ console.warn('AudioContext not available'); audioCtx = null; }
}
// simple SFX generators
function playSfx(type='hit', vol=0.2){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = (type==='hit'?'sawtooth':'square');
  o.frequency.value = (type==='expl'?80: (type==='hit'?700:350));
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.18);
  o.stop(audioCtx.currentTime + 0.2);
}
let bgmNode = null;
function startBGM(){
  if(!audioCtx) return;
  if(bgmNode) return;
  // simple looped synth bass + arp
  const gain = audioCtx.createGain(); gain.gain.value = 0.06; gain.connect(audioCtx.destination);
  const osc = audioCtx.createOscillator(); osc.type = 'sine'; osc.frequency.value = 55;
  const lfo = audioCtx.createOscillator(); lfo.frequency.value = 0.25;
  const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 40;
  lfo.connect(lfoGain); lfoGain.connect(osc.frequency);
  osc.connect(gain);
  osc.start(); lfo.start();
  bgmNode = { osc, lfo, lfoGain, gain };
}
function stopBGM(){ if(!bgmNode) return; try{ bgmNode.osc.stop(); bgmNode.lfo.stop(); }catch(e){} bgmNode = null; }

// -------- data URIs for boss images (SVG simple stylized) --------
function svgToDataURI(svg){ return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg); }
const bossImages = {
  alien: svgToDataURI(`<svg xmlns='http://www.w3.org/2000/svg' width='320' height='180'><defs><linearGradient id='g' x1='0' x2='1'><stop offset='0' stop-color='#8ff' /><stop offset='1' stop-color='#2a9' /></linearGradient></defs><ellipse cx='160' cy='90' rx='140' ry='70' fill='url(#g)' stroke='#0a2' stroke-width='6'/><circle cx='120' cy='78' r='12' fill='#000'/><circle cx='200' cy='78' r='12' fill='#000'/></svg>`),
  ptera: svgToDataURI(`<svg xmlns='http://www.w3.org/2000/svg' width='360' height='160'><path d='M10,80 Q140,10 180,40 Q220,10 350,80 L300,120 L60,120 Z' fill='#8ee' stroke='#06a' stroke-width='5'/></svg>`),
  trex: svgToDataURI(`<svg xmlns='http://www.w3.org/2000/svg' width='380' height='200'><path d='M20,150 Q100,30 200,60 Q280,30 360,150 L300,170 L80,170 Z' fill='#fba' stroke='#b44' stroke-width='6'/></svg>`),
  mech: svgToDataURI(`<svg xmlns='http://www.w3.org/2000/svg' width='360' height='200'><rect x='20' y='40' width='320' height='120' fill='#ffb' stroke='#a66' stroke-width='6'/><rect x='60' y='70' width='80' height='60' fill='#fff' opacity='0.15'/></svg>`),
  overlord: svgToDataURI(`<svg xmlns='http://www.w3.org/2000/svg' width='420' height='220'><ellipse cx='210' cy='110' rx='180' ry='90' fill='#f8a' stroke='#a06' stroke-width='8'/><ellipse cx='210' cy='140' rx='130' ry='50' fill='#d6a' opacity='0.9'/></svg>`)
};

// preload images
const loadedBossImg = {};
Object.keys(bossImages).forEach(k=>{
  const img = new Image();
  img.src = bossImages[k];
  img.onload = ()=>{ loadedBossImg[k] = img; };
});

// -------- helper util --------
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// -------- spawning --------
function spawnEnemyVariant(){
  // variants become stronger with level
  if(level === 1) enemies.push({ x:rand(40,W-40), y:-40, r:18, vy:rand(100,160), hp:1, pattern:'sine', t:0, wave:rand(0,6.28) });
  else if(level === 2) enemies.push({ x:rand(40,W-40), y:-40, r:20, vy:rand(140,220), hp:1, pattern:'dive', t:0, wave:rand(0,6.28) });
  else if(level === 3) enemies.push({ x:rand(40,W-40), y:-40, r:22, vy:rand(120,200), hp:2, pattern:'sine', t:0, wave:rand(0,6.28) });
  else if(level === 4) enemies.push({ x:rand(40,W-40), y:-40, r:20, vy:rand(120,200), hp:2, pattern:'shooter', t:0, wave:rand(0,6.28), shootCooldown:rand(0.6,1.6) });
  else enemies.push({ x:rand(40,W-40), y:-40, r:16, vy:rand(160,280), hp:1, pattern:'zigzag', t:0, wave:rand(0,6.28) });
}

function spawnPower(x,y){ powerups.push({ x,y,r:18,type:Math.random()<0.5?'spread':'laser', ttl:9 }); }

// -------- boss definitions with phases --------
const BOSS_DEFS = [
  { id:1, name:'Alien', key:'alien', hp:120, color:'#7fffb0', phases:[0.66,0.33], quotes:['你不属于这里…','我会吞噬一切'] },
  { id:2, name:'Pteranodon', key:'ptera', hp:160, color:'#9be0ff', phases:[0.6,0.3], quotes:['俯冲！','利爪撕裂'] },
  { id:3, name:'T-Rex', key:'trex', hp:240, color:'#ffb4a2', phases:[0.7,0.35], quotes:['咆哮！','你将被撕裂'] },
  { id:4, name:'MechaDino', key:'mech', hp:320, color:'#ffd66b', phases:[0.7,0.4], quotes:['系统：战斗模式启动','警报：武装升级'] },
  { id:5, name:'Overlord', key:'overlord', hp:540, color:'#ffa0ff', phases:[0.75,0.5,0.25], quotes:['终极主宰降临','臣服！','终结！'] }
];

// spawn boss safely
function spawnBossByLevel(lv){
  if(bossActive || isAdvancing) return;
  const def = BOSS_DEFS[lv-1];
  if(!def) return;
  bossActive = true;
  boss = {
    id: def.id, name: def.name, key: def.key,
    hp: def.hp, maxHp: def.hp, color: def.color,
    phases: def.phases.slice(), phase:0, t:0, x: W/2, y: -260,
    quotes: def.quotes.slice(), behavior: def.key
  };
  document.getElementById('bossbar').style.display = 'block';
  playBossIntro(boss.name, boss.quotes[0]||'');
  // bossIntro will animate; during that time bullets/enemies keep spawning but boss y moves in update
}

// Boss intro animation and sfx
const levelTitleEl = document.getElementById('levelTitle');
function playBossIntro(name, quote){
  levelTitleEl.textContent = name + ' — ' + quote;
  levelTitleEl.style.display = 'block';
  levelTitleEl.style.opacity = '0';
  levelTitleEl.animate([
    { transform:'translate(-50%,-60%) scale(0.9)', opacity:0 },
    { transform:'translate(-50%,-50%) scale(1.06)', opacity:1 },
    { transform:'translate(-50%,-50%) scale(1.0)', opacity:1 }
  ], { duration:900, easing:'cubic-bezier(.22,.9,.39,1)' });
  playSfx('hit', 0.12);
  setTimeout(()=> levelTitleEl.style.display='none', 1500);
}

// -------- weapons & firing --------
let firing=false, fireInterval=null;
function startFiring(){ if(firing) return; firing=true; shoot(); fireInterval=setInterval(shoot, power.mode==='single'?160:(power.mode==='spread'?300:120)); ensureAudio(); }
function stopFiring(){ firing=false; if(fireInterval){ clearInterval(fireInterval); fireInterval=null; } }
function shoot(){
  if(power.mode==='laser'){ if(power.missileAmmo<=0) return; power.missileAmmo--; }
  if(power.mode==='single'){ playerBullets.push({ x:player.x, y:player.y - player.r - 8, vx:0, vy:-1100, type:'bullet', t:0}); }
  else if(power.mode==='spread'){ const offs=[-0.32,-0.12,0,0.12,0.32]; offs.forEach(o=> playerBullets.push({ x:player.x+o*12, y:player.y-player.r-8, vx:o*820, vy:-920, type:'bullet', t:0 })); }
  else if(power.mode==='laser'){ playerBullets.push({ x:player.x, y:player.y-player.r-20, vx:0, vy:-1500, type:'laser', t:0 }); }
  playSfx('hit',0.05);
}

// -------- collisions & updates (non-blocking) --------
function update(dt){
  if(!playing) return;
  time += dt;

  // player movement from joystick
  const v = joyToVector();
  player.x += v.x * player.speed * dt; player.y += v.y * player.speed * dt;
  player.x = clamp(player.x, 40, W-40); player.y = clamp(player.y, H*0.45, H-40);

  // update player bullets
  for(let i=playerBullets.length-1;i>=0;i--){
    const b = playerBullets[i]; b.x += (b.vx||0)*dt; b.y += (b.vy||0)*dt; b.t=(b.t||0)+dt;
    if(b.y < -200 || b.x < -200 || b.x > W+200) playerBullets.splice(i,1);
  }

  // update enemy bullets
  for(let i=eBullets.length-1;i>=0;i--){
    const b = eBullets[i]; b.x += (b.vx||0)*dt; b.y += (b.vy||0)*dt; b.t=(b.t||0)+dt;
    // homing bullets adjust velocity slightly toward player
    if(b.homing && b.target){
      const dx = b.target.x - b.x, dy = b.target.y - b.y; const d=Math.hypot(dx,dy)||1;
      const speed = Math.hypot(b.vx,b.vy) || (b.vy>0?Math.abs(b.vy):200);
      const nx = (dx/d)*speed, ny = (dy/d)*speed;
      b.vx += (nx - b.vx) * 0.06; b.vy += (ny - b.vy) * 0.06;
    }
    if(b.y > H+300 || b.x < -300 || b.x > W+300) eBullets.splice(i,1);
  }

  // enemies update
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    e.t = (e.t||0)+dt;
    if(e.pattern==='sine'){ e.y += e.vy*dt; e.x += Math.sin(e.t*2 + (e.wave||0)) * 40 * dt; }
    else if(e.pattern==='dive'){ e.y += e.vy*dt; if(Math.random()<0.002) e.vy += 80; }
    else if(e.pattern==='zigzag'){ e.y += e.vy*dt; e.x += Math.sin(e.t*6) * 80 * dt; }
    else if(e.pattern==='shooter'){ e.y += e.vy*dt; e.since=(e.since||0)+dt; if(e.since> (e.shootCooldown||1)){ e.since=0; eBullets.push({ x:e.x, y:e.y+12, vx:0, vy:rand(260,380), type:'ebullet'}); } }
    else if(e.pattern==='tracker'){ const dx=player.x-e.x, dy=player.y-e.y, d=Math.hypot(dx,dy)||1; e.x += (dx/d)*160*dt; e.y += (dy/d)*160*dt; }
    // off screen remove
    if(e.y > H + 220) enemies.splice(i,1);
  }

  // powerups
  for(let i=powerups.length-1;i>=0;i--){
    const p = powerups[i]; p.ttl -= dt;
    if(p.ttl <= 0){ powerups.splice(i,1); continue; }
    if(Math.hypot(p.x-player.x,p.y-player.y) < p.r + player.r){ activatePower(p.type, p.type==='spread'?12:16, p.type==='laser'?3:0 ); powerups.splice(i,1); }
  }

  // player bullets vs enemies
  for(let ei=enemies.length-1; ei>=0; ei--){
    const e = enemies[ei];
    for(let bi=playerBullets.length-1; bi>=0; bi--){
      const b = playerBullets[bi];
      if(b.x > e.x - e.r && b.x < e.x + e.r && b.y > e.y - e.r && b.y < e.y + e.r){
        playerBullets.splice(bi,1);
        e.hp = (e.hp||1) - (b.type==='laser'?3:1);
        createExplosion(e.x,e.y,6); score += 5;
        playSfx('hit',0.06);
        if(e.hp <= 0){ if(Math.random()<0.12) spawnPower(e.x,e.y); enemies.splice(ei,1); }
        break;
      }
    }
  }

  // enemy bullets vs player
  for(let i=eBullets.length-1;i>=0;i--){
    const b = eBullets[i];
    if(b.x > player.x - player.r && b.x < player.x + player.r && b.y > player.y - player.r && b.y < player.y + player.r){
      eBullets.splice(i,1);
      player.hp -= 1;
      createExplosion(player.x,player.y,10);
      playSfx('expl', 0.18);
      if(player.hp <= 0){
        lives--; if(lives > 0){ // allow continue overlay logic minimal
          player.hp = 3; enemies = []; playerBullets.length=0; eBullets.length=0; for(let k=0;k<6;k++) spawnEnemyVariant();
        } else {
          triggerGameOver();
        }
      }
    }
  }

  // bullets vs boss
  if(boss){
    boss.t += dt;
    // entry motion
    if(boss.y < 90) boss.y += 50 * dt;
    else {
      // phase detection
      const hpPct = boss.hp / boss.maxHp;
      const newPhase = boss.phases.reduce((acc, thr, idx) => hpPct <= thr ? Math.max(acc, idx+1) : acc, 0);
      if(newPhase !== boss.phase){
        boss.phase = newPhase;
        // phase change effects
        createExplosion(boss.x,boss.y,24); playSfx('hit',0.18);
      }
      // behavior by boss.behavior and phase
      if(boss.behavior === 'alien'){
        // spiral + occasional ring
        if(Math.random() < 0.02 + boss.phase*0.01) ringBurst(boss.x,boss.y+60,8,160 + boss.phase*20);
        if(Math.random() < 0.015 + boss.phase*0.01) spiralShot(boss.x,boss.y+60,boss.phase?10:6,boss.phase?0.18:0.28);
      } else if(boss.behavior === 'ptera'){
        if(Math.random() < 0.025 + boss.phase*0.01){
          // dive spawn
          for(let i=0;i<3 + boss.phase;i++) enemies.push({ x:boss.x + i*40 - 40, y:boss.y+60, r:16, vy:rand(340,500), hp:1, pattern:'dive' });
        }
      } else if(boss.behavior === 'trex'){
        if(Math.random() < 0.04 + boss.phase*0.02){
          // scatter bombs
          for(let i=0;i<6 + boss.phase*2;i++) enemies.push({ x:boss.x + rand(-140,140), y:boss.y+40, r:12, vy: rand(220,360), hp:1, pattern:'zigzag' });
        }
      } else if(boss.behavior === 'mech'){
        if(Math.random() < 0.04 + boss.phase*0.02){
          // shooters and homing missiles
          enemies.push({ x:boss.x + rand(-80,80), y:boss.y+80, r:14, vy: rand(280,420), hp:1, pattern:'shooter', shootCooldown: rand(0.4,1.0) });
          // homing missile as enemy bullet
          eBullets.push({ x: boss.x, y: boss.y+60, vx:0, vy:120, homing:true, target:player, type:'homing' });
        }
      } else if(boss.behavior === 'overlord'){
        // heavy rain + spiral + homing cluster
        if(Math.random() < 0.06 + boss.phase*0.02){
          ringBurst(boss.x, boss.y+60, 12 + boss.phase*4, 260 + boss.phase*30);
          spiralShot(boss.x, boss.y+60, 12 + boss.phase*4, 0.08);
          // cluster homing
          for(let i=0;i<boss.phase+1;i++) eBullets.push({ x:boss.x + rand(-180,180), y:boss.y+40, vx:0, vy:160, homing:true, target:player, type:'homing' });
        }
      }

      // boss hit detection
      for(let bi=playerBullets.length-1; bi>=0; bi--){
        const b = playerBullets[bi];
        if(b.x > boss.x - 120 && b.x < boss.x + 120 && b.y > boss.y - 80 && b.y < boss.y + 80){
          playerBullets.splice(bi,1);
          boss.hp -= (b.type==='laser'?6:1);
          createExplosion(b.x,b.y,6);
          playSfx('hit',0.08);
        }
      }

      if(boss.hp <= 0){
        const type = boss.behavior;
        createExplosion(boss.x,boss.y,48); playSfx('expl',0.3);
        boss = null; bossActive = false;
        document.getElementById('bossbar').style.display = 'none';
        // special: trex spawns trackers
        if(type === 'trex'){
          for(let i=0;i<18;i++) enemies.push({ x: rand(60,W-60), y: rand(60, H*0.4), r:10, vy:0, hp:1, pattern:'tracker', t:0 });
        }
        // final boss check: if level >=5 and we just killed overlord => victory
        if(type === 'overlord' || level >= 5){ triggerVictory(); return; }
        // else advance level
        advanceLevel();
      }
    }
  }

  // ambient spawn
  if(!boss){
    const cap = clamp(5 + level*3, 6, 26);
    if(enemies.length < cap && Math.random() < 0.028 + level*0.003) spawnEnemyVariant();
  }

  // boss triggers (time-based)
  if(!boss && !bossActive){
    if(level === 1 && time > 18){ spawnBossByLevel(1); time = 0; }
    else if(level === 2 && time > 38){ spawnBossByLevel(2); time = 0; }
    else if(level === 3 && time > 70){ spawnBossByLevel(3); time = 0; }
    else if(level === 4 && time > 110){ spawnBossByLevel(4); time = 0; }
    else if(level === 5 && time > 160){ spawnBossByLevel(5); time = 0; }
  }

  // power timer
  if(power.timer > 0){ power.timer -= dt; if(power.timer <= 0){ power.mode='single'; power.missileAmmo=0; updatePowerUI(); } }

  // particles update
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i]; p.x += p.vx*dt; p.y += p.vy*dt; p.alpha -= dt*1.2; if(p.alpha<=0) particles.splice(i,1);
  }

  // UI
  document.getElementById('score').textContent = 'SCORE: ' + Math.floor(score);
  document.getElementById('lives').textContent = 'LIVES: ' + lives;
  document.getElementById('levelBadge').textContent = boss ? ('BOSS: ' + boss.name) : ('LEVEL: ' + level);
  if(boss){ const pct = clamp(boss.hp / boss.maxHp * 100, 0, 100); document.getElementById('bossbarInner').style.width = pct + '%'; document.getElementById('bossbar').style.display='block'; }
  updatePowerUI();
}

// -------- complex patterns --------
function ringBurst(cx,cy,count,speed){
  const a0 = Math.random()*Math.PI*2;
  for(let i=0;i<count;i++){
    const a = a0 + (i/count)*Math.PI*2;
    const vx = Math.cos(a)*speed, vy = Math.sin(a)*speed;
    eBullets.push({ x:cx, y:cy, vx, vy, type:'ring'});
  }
}
function spiralShot(cx,cy,count,step){
  const t0 = Math.random()*Math.PI*2;
  for(let i=0;i<count;i++){
    const a = t0 + i * step * Math.PI*2;
    const vx = Math.cos(a)*160 + Math.random()*40 - 20, vy = Math.sin(a)*160 + Math.random()*40 - 20;
    eBullets.push({ x:cx, y:cy, vx, vy, type:'spiral' });
  }
}

// -------- draw --------
function draw(){
  ctx.clearRect(0,0,W,H);
  // bg
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,`hsl(${(time*6)%360} 60% 8%)`); g.addColorStop(1,`hsl(${(time*6+80)%360} 70% 12%)`); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  // stars
  for(let i=0;i<50;i++){ const x = (i*97 + time*30) % W; const y = (i*53) % H; ctx.fillStyle = `hsl(${(i*7 + time*10)%360} 60% 55%)`; ctx.fillRect(x,y,2,2); }

  if(shake>0){ ctx.save(); ctx.translate((Math.random()*2-1)*shake, (Math.random()*2-1)*shake); shake *= 0.92; }

  // powerups
  powerups.forEach(p=>{
    const rad = 18 + Math.sin(time*8 + p.x)*3;
    ctx.save(); ctx.globalCompositeOperation='lighter';
    const gr = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,rad);
    gr.addColorStop(0,'rgba(255,255,255,0.9)'); gr.addColorStop(1,'rgba(0,150,255,0)');
    ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(p.x,p.y,rad,0,Math.PI*2); ctx.fill(); ctx.restore();
  });

  // enemies
  enemies.forEach(e=>{
    ctx.save(); ctx.globalCompositeOperation='lighter';
    if(e.pattern==='tracker') ctx.fillStyle='hsl(280 80% 60%)';
    else if(level<=2) ctx.fillStyle='hsl(10 90% 60%)';
    else if(level===3) ctx.fillStyle='hsl(24 90% 60%)';
    else if(level===4) ctx.fillStyle='hsl(200 90% 60%)';
    else ctx.fillStyle='hsl(280 80% 60%)';

    if(e.pattern === 'sine' || e.pattern === 'dive' || e.pattern === 'zigzag' || e.pattern === 'tracker') ctx.fillRect(e.x-e.r,e.y-e.r,e.r*2,e.r*2);
    else { ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  });

  // enemy bullets
  eBullets.forEach(b=>{
    ctx.save(); ctx.globalCompositeOperation='lighter';
    if(b.type==='homing') ctx.fillStyle = '#f66';
    else ctx.fillStyle = 'rgba(255,160,0,0.9)';
    ctx.beginPath(); ctx.arc(b.x,b.y,6,0,Math.PI*2); ctx.fill(); ctx.restore();
  });

  // boss drawing (use image if loaded)
  if(boss){
    ctx.save(); ctx.globalCompositeOperation='lighter';
    const img = loadedBossImg[boss.key];
    if(img){
      const scale = clamp( (W/900) * (1 + 0.06*boss.phase), 0.6, 1.6);
      const w = img.width * scale, h = img.height * scale;
      ctx.drawImage(img, boss.x - w/2, boss.y - h/2, w, h);
    } else {
      // fallback shape
      ctx.fillStyle = boss.color; ctx.beginPath(); ctx.ellipse(boss.x,boss.y,120,70,0,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // player bullets
  playerBullets.forEach(b=>{
    if(b.type==='laser'){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(160,240,255,0.9)'; ctx.fillRect(b.x-6,0,12,b.y); ctx.restore(); }
    else { ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(180,240,255,1)'; ctx.fillRect(b.x-4,b.y-16,8,20); ctx.restore(); }
  });

  // particles
  particles.forEach(p=>{ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle = `hsla(${p.hue},100%,60%,${p.alpha})`; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.restore(); });

  // player
  ctx.save(); ctx.globalCompositeOperation='lighter';
  const pb = ctx.createLinearGradient(player.x,player.y-player.r,player.x,player.y+player.r); pb.addColorStop(0,'#6ff'); pb.addColorStop(1,'#08f');
  ctx.fillStyle = pb; roundShip(player.x,player.y,player.r*1.4,player.r*1.8); ctx.fill(); ctx.restore();

  if(shake>0) ctx.restore();
}

// simple ship path
function roundShip(cx,cy,w,h){ ctx.beginPath(); ctx.moveTo(cx-w*0.3,cy-h*0.5); ctx.quadraticCurveTo(cx,cy-h*0.8,cx+w*0.3,cy-h*0.5); ctx.lineTo(cx+w*0.35,cy+h*0.3); ctx.quadraticCurveTo(cx,cy+h*0.55,cx-w*0.35,cy+h*0.3); ctx.closePath(); }

// explosions
function createExplosion(x,y,count=18){
  for(let i=0;i<count;i++) particles.push({ x:x+rand(-12,12), y:y+rand(-12,12), vx:rand(-300,300), vy:rand(-300,300), alpha:1, size:rand(2,6), hue:rand(0,360) });
}

// -------- advance level safely --------
function advanceLevel(){
  if(isAdvancing) return;
  isAdvancing = true;
  // capture current level then schedule advance
  setTimeout(()=>{
    // apply per-level changes (distinct and significant)
    if(level === 1){ /* after Alien: faster spawn */ }
    else if(level === 2){ enemies.forEach(e=>{ if(Math.random()<0.45) e.pattern='dive'; }); }
    else if(level === 3){
      // split survivors into trackers
      const trackers = [];
      enemies.forEach(e=>{ trackers.push({ x:e.x, y:e.y, r:10, vy:0, hp:1, pattern:'tracker', t:0 }); trackers.push({ x:e.x+rand(-12,12), y:e.y, r:10, vy:0, hp:1, pattern:'tracker', t:0 }); });
      enemies = enemies.concat(trackers);
    }
    else if(level === 4){ enemies.forEach(e=>{ if(e.pattern==='shooter') e.shootCooldown = Math.max(0.25, e.shootCooldown*0.6); }); }

    // increment level (but cap at 5)
    level = Math.min(level + 1, 5);
    time = 0;
    document.getElementById('levelBadge').textContent = 'LEVEL: ' + level;
    // spawn immediate wave to avoid empty field
    for(let i=0;i<6 + level*2;i++) spawnEnemyVariant();
    showLevelTitle('LEVEL ' + level);
    isAdvancing = false;
  }, 450); // slight gap to allow effects
}

// -------- boss trigger helper --------
function showLevelTitle(txt){
  const el = document.getElementById('levelTitle');
  el.textContent = txt; el.style.display='block';
  setTimeout(()=> el.style.display='none', 1400);
}

// -------- overlays and game over/victory --------
function triggerGameOver(){
  gameOver = true; playing = false; document.getElementById('finalScoreText').textContent = '得分: ' + Math.floor(score); document.getElementById('gameoverOverlay').classList.remove('hidden');
}
function triggerVictory(){
  victory = true; playing = false; document.getElementById('victoryScoreText').textContent = '得分: ' + Math.floor(score); document.getElementById('victoryOverlay').classList.remove('hidden');
}

// restart
function restartGame(){
  score=0; lives=5; time=0; level=1; boss=null; bossActive=false; isAdvancing=false; enemies=[]; eBullets=[]; particles=[]; powerups=[]; playerBullets=[];
  player.x = W/2; player.y = H*0.78; player.hp=3; power = { mode:'single', timer:0, missileAmmo:0 }; playing=true; gameOver=false; victory=false;
  document.getElementById('gameoverOverlay').classList.add('hidden'); document.getElementById('victoryOverlay').classList.add('hidden'); document.getElementById('bossbar').style.display='none';
  for(let i=0;i<6;i++) spawnEnemyVariant();
}

// -------- power UI & bindings --------
function activatePower(mode, seconds, ammo){
  power.mode = mode; power.timer = seconds; if(ammo) power.missileAmmo = ammo; updatePowerUI();
}
function updatePowerUI(){ const el = document.getElementById('powerIndicator'); if(power.mode==='single' || power.timer<=0) el.innerHTML=''; else el.innerHTML = `<div style="padding:6px 12px;background:rgba(255,255,255,0.06);border-radius:999px;font-weight:700">${power.mode.toUpperCase()} ${power.mode==='laser'?(' x'+power.missileAmmo):''}</div>`; }

document.getElementById('btnSpread').addEventListener('click', ()=> activatePower('spread',12));
document.getElementById('btnMissile').addEventListener('click', ()=> activatePower('laser',16,4));
document.getElementById('fireBtn').addEventListener('touchstart', e=>{ e.preventDefault(); ensureAudio(); startFiring(); });
document.getElementById('fireBtn').addEventListener('touchend', e=>{ e.preventDefault(); stopFiring(); });
document.getElementById('fireBtn').addEventListener('mousedown', e=>{ e.preventDefault(); ensureAudio(); startFiring(); });
document.getElementById('fireBtn').addEventListener('mouseup', e=>{ e.preventDefault(); stopFiring(); });

// joystick touch
joyBase.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.changedTouches[0]; joyActive=true; joyId=t.identifier; handleJoyTouch(t); });
joyBase.addEventListener('touchmove', e=>{ e.preventDefault(); if(!joyActive) return; for(let i=0;i<e.changedTouches.length;i++){ if(e.changedTouches[i].identifier===joyId){ handleJoyTouch(e.changedTouches[i]); break; } } });
joyBase.addEventListener('touchend', e=>{ for(let i=0;i<e.changedTouches.length;i++){ if(e.changedTouches[i].identifier===joyId){ joyActive=false; joyId=null; joyPos.x=0; joyPos.y=0; updateKnob(); break; } } });
function handleJoyTouch(t){ const rect = joyBase.getBoundingClientRect(); const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2; let dx=t.clientX-cx, dy=t.clientY-cy; const dist = Math.hypot(dx,dy); const max=(rect.width/2)-12; if(dist>max){ dx=dx*(max/dist); dy=dy*(max/dist); } joyPos.x=dx; joyPos.y=dy; updateKnob(); }

// keyboard optional
window.addEventListener('keydown', e=>{ if(e.key===' '){ ensureAudio(); startFiring(); } if(e.key==='r'){ restartGame(); } });
window.addEventListener('keyup', e=>{ if(e.key===' ') stopFiring(); });

// -------- main loop --------
let last = performance.now();
function loop(now){
  const dt = Math.min((now - last)/1000, 0.033); last = now;
  if(playing && !gameOver && !victory){ update(dt); draw(); }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// -------- init field --------
for(let i=0;i<6;i++) spawnEnemyVariant();
setTimeout(()=>{ for(let i=0;i<2;i++) spawnPower(rand(100,W-100), rand(150,H-300)); }, 1200);

// expose debug helpers
window.debugNextBoss = ()=>{ spawnBossByLevel(Math.min(level+1,5)); };
window.spawnBoss = spawnBossByLevel;
window.activatePower = activatePower;
window.restartGame = restartGame;

// -------- game over / victory button hooks --------
document.getElementById('restartBtn').addEventListener('click', restartGame);
document.getElementById('restartBtn2').addEventListener('click', restartGame);

// End of script
</script>
</body>
</html>
