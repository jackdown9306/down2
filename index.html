<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>飞机大战 - 触屏豪华版（导弹/散弹/镭射/Boss）</title>
<style>
  :root{--ui:rgba(255,255,255,0.08);--ui-2:rgba(255,255,255,0.16)}
  html,body{height:100%;margin:0;background:#000;touch-action:none;-webkit-user-select:none;}
  #game{display:block;width:100vw;height:100vh}
  /* 左下 虚拟摇杆 */
  .joy-wrap{position:fixed;left:12px;bottom:12px;width:140px;height:140px;border-radius:999px;background:var(--ui);display:flex;align-items:center;justify-content:center;z-index:1000;}
  .joy-base{position:relative;width:90%;height:90%;border-radius:999px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));}
  .joy-knob{position:absolute;width:46px;height:46px;border-radius:999px;background:linear-gradient(180deg,#08f,#0ff);box-shadow:0 6px 18px rgba(0,200,255,0.25);left:50%;top:50%;transform:translate(-50%,-50%);}

  /* 右下按键 */
  .fire-btn{position:fixed;right:14px;bottom:18px;width:86px;height:86px;border-radius:999px;background:radial-gradient(circle,#ffec6a,#ff6a6a);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:22px;z-index:1000;box-shadow:0 12px 24px rgba(255,100,100,0.18)}
  .aux-row{position:fixed;right:14px;bottom:120px;display:flex;flex-direction:column;gap:10px;z-index:1000}
  .aux{width:72px;height:42px;background:var(--ui);border-radius:999px;display:flex;align-items:center;justify-content:center;font-weight:600}

  /* 顶部 UI */
  .hud{position:fixed;left:12px;top:12px;z-index:1000;display:flex;gap:12px}
  .badge{background:var(--ui);padding:8px 12px;border-radius:999px}
  .power-ind{position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:1000}

  /* Boss 血条 */
  .bossbar{position:fixed;left:50%;top:52px;transform:translateX(-50%);width:80%;height:16px;background:rgba(255,255,255,0.06);border-radius:10px;overflow:hidden;z-index:1000}
  .bossbar-inner{height:100%;background:linear-gradient(90deg,#ff4d4d,#ffb347);width:0%}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud">
  <div class="badge" id="score">SCORE: 0</div>
  <div class="badge" id="lives">LIVES: 5</div>
</div>
<div class="power-ind" id="powerIndicator"></div>
<div class="bossbar" id="bossbar" style="display:none"><div class="bossbar-inner" id="bossbarInner"></div></div>

<div class="joy-wrap" id="joyWrap" aria-hidden="false"><div class="joy-base" id="joyBase"><div class="joy-knob" id="joyKnob"></div></div></div>
<div class="fire-btn" id="fireBtn">FIRE</div>
<div class="aux-row">
  <div class="aux" id="btnSpread">散弹</div>
  <div class="aux" id="btnMissile">导弹</div>
</div>

<script>
/* ====== 飞机大战 · 触屏豪华版 ======
   功能：虚拟摇杆（圆点）长按射击（可连发），临时道具：散弹、镭射导弹
   关卡：普通敌人 + 两个 Boss（顺序出现）
   保存为 UTF-8 无 BOM 后直接在手机/PC 浏览器打开。
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth; let H = canvas.height = innerHeight;
window.addEventListener('resize', ()=>{ W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

// 状态
let score = 0, lives = 5;
let shake = 0;
let time = 0;

// player
const player = { x: W/2, y: H*0.78, r: 26, speed: 520, bullets: [], missileGlow:0 };

// joystick
const joyWrap = document.getElementById('joyWrap');
const joyBase = document.getElementById('joyBase');
const joyKnob = document.getElementById('joyKnob');
const baseRect = { size: 140*0.9 }; // px
let joyActive = false, joyId = null; let joyPos = {x:0,y:0};
const maxJoy = 46; // knob max offset

function joyToVector(){ return { x: joyPos.x / maxJoy, y: joyPos.y / maxJoy }; }

// enemies, bosses, particles, powerups
let enemies = [], particles = [], powerups = [];
let boss = null; // {type: 'alpha'|'omega', hp, phase}
let level = 1;

// power states
let power = { mode: 'single', timer: 0, missileAmmo:0 }; // mode: single, spread, laser

// helpers
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// spawn enemy
function spawnEnemy(){
  enemies.push({ x: rand(40, W-40), y: -40, r: rand(16,28), vy: rand(80,160), hp: 1, type: 'grunt', wave: Math.random()*6.28 });
}

// spawn powerup
function spawnPower(x,y){ const t = Math.random()<0.5?'spread':'missile'; powerups.push({x,y,r:18,type:t,ttl:8}); }

// boss create
function spawnBoss(which){
  if(which === 1){ boss = { type:'alpha', hp: 80, maxHp:80, y:-140, x: W/2, phase:0, t:0}; document.getElementById('bossbar').style.display='block'; }
  else { boss = { type:'omega', hp: 160, maxHp:160, y:-180, x: W/2, phase:0, t:0}; document.getElementById('bossbar').style.display='block'; }
}

// fire functions
let firing = false; let fireInterval = null;
function startFiring(){ if(firing) return; firing = true; shoot(); fireInterval = setInterval(shoot, power.mode==='single'?200:(power.mode==='spread'?320:160)); }
function stopFiring(){ firing=false; if(fireInterval){ clearInterval(fireInterval); fireInterval=null; } }

function shoot(){
  player.missileGlow = 1;
  if(power.mode === 'single'){
    player.bullets.push({ x: player.x, y: player.y - player.r - 6, vx:0, vy:-900, t:0, type:'bullet' });
  } else if(power.mode === 'spread'){
    // 5-way spread
    const speeds = [-0.28, -0.12, 0, 0.12, 0.28];
    speeds.forEach(s => {
      player.bullets.push({ x: player.x + s*10, y: player.y - player.r - 6, vx: s*700, vy: -820, t:0, type:'bullet' });
    });
  } else if(power.mode === 'laser'){
    // laser missile: pierces and does beam
    if(power.missileAmmo > 0){ power.missileAmmo--; player.bullets.push({ x: player.x, y: player.y - player.r - 20, vx:0, vy:-1200, t:0, type:'laser' }); }
  }
}

// auxiliary launcher (button triggers temporary pickup)
document.getElementById('btnSpread').addEventListener('click', ()=>{ activatePower('spread',10); });
document.getElementById('btnMissile').addEventListener('click', ()=>{ activatePower('laser',15,5); });

function activatePower(mode, seconds, ammo){ power.mode = mode; power.timer = seconds; power.missileAmmo = ammo||power.missileAmmo; showPower(); }

function showPower(){ const el = document.getElementById('powerIndicator'); if(power.mode==='single' || power.timer<=0) el.innerHTML=''; else el.innerHTML = '<div style="padding:6px 12px;background:var(--ui);border-radius:999px;font-weight:700">' + power.mode.toUpperCase() + (power.mode==='laser'?(' x'+power.missileAmmo):'') + '</div>'; }

// joystick touch handling
joyBase.addEventListener('touchstart', e=>{
  e.preventDefault(); const t = e.changedTouches[0]; joyActive=true; joyId = t.identifier; updateJoyFromTouch(t);
});
joyBase.addEventListener('touchmove', e=>{
  e.preventDefault(); if(!joyActive) return; for(let i=0;i<e.changedTouches.length;i++){ const t=e.changedTouches[i]; if(t.identifier===joyId){ updateJoyFromTouch(t); break;} }
});
joyBase.addEventListener('touchend', e=>{ for(let i=0;i<e.changedTouches.length;i++){ if(e.changedTouches[i].identifier===joyId){ joyActive=false; joyId=null; joyPos.x=0; joyPos.y=0; updateKnob(); break; } } });

function updateJoyFromTouch(t){ const rect = joyBase.getBoundingClientRect(); const cx = rect.left + rect.width/2; const cy = rect.top + rect.height/2; let dx = (t.clientX - cx); let dy = (t.clientY - cy); const dist = Math.hypot(dx,dy); const max = (rect.width/2) - 12; if(dist>max){ dx = dx*(max/dist); dy = dy*(max/dist); } joyPos.x = dx; joyPos.y = dy; updateKnob(); }
function updateKnob(){ joyKnob.style.transform = `translate(${joyPos.x}px, ${joyPos.y}px)`; }

// fire button touch & long-press support
const fireBtn = document.getElementById('fireBtn');
fireBtn.addEventListener('touchstart', e=>{ e.preventDefault(); startFiring(); });
fireBtn.addEventListener('touchend', e=>{ e.preventDefault(); stopFiring(); });
fireBtn.addEventListener('mousedown', e=>{ e.preventDefault(); startFiring(); });
fireBtn.addEventListener('mouseup', e=>{ e.preventDefault(); stopFiring(); });

// collisions & update
function update(dt){ time += dt; // move player with joystick vector
  const v = joyToVector(); player.x += v.x * player.speed * dt; player.y += v.y * player.speed * dt;
  player.x = clamp(player.x, 40, W-40); player.y = clamp(player.y, H*0.45, H-40);

  // update bullets
  for(let i=player.bullets.length-1;i>=0;i--){ const b = player.bullets[i]; b.t += dt; b.x += b.vx*dt; b.y += b.vy*dt; if(b.y < -50 || b.x < -100 || b.x > W+100) player.bullets.splice(i,1); }

  // enemies
  enemies.forEach(e=>{ e.t = (e.t||0)+dt; e.y += (e.vy*dt); e.x += Math.sin(e.t*2 + e.wave)*30*dt; });

  // powerup pickup
  for(let i=powerups.length-1;i>=0;i--){ const p = powerups[i]; p.ttl -= dt; if(p.ttl<=0){ powerups.splice(i,1); continue; } if(Math.hypot(p.x-player.x,p.y-player.y) < p.r+player.r){ // pickup
    if(p.type==='spread') activatePower('spread',12); else activatePower('laser',18,3); powerups.splice(i,1); }
  }

  // enemy collisions with bullets
  for(let ei=enemies.length-1; ei>=0; ei--){ const e = enemies[ei];
    for(let bi=player.bullets.length-1; bi>=0; bi--){ const b = player.bullets[bi];
      if(b.x > e.x - e.r && b.x < e.x + e.r && b.y > e.y - e.r && b.y < e.y + e.r){
        // hit
        createExplosion(e.x, e.y);
        player.bullets.splice(bi,1);
        enemies.splice(ei,1);
        score += 50;
        shake = 8;
        // 10% chance drop power
        if(Math.random() < 0.12) spawnPower(e.x, e.y);
        break;
      }
    }
  }

  // boss logic
  if(boss){ boss.t += dt; if(boss.y < 80) boss.y += 40*dt; else {
    // simple patterns
    if(boss.type==='alpha'){
      boss.x = W/2 + Math.sin(boss.t*0.6)* (W*0.25);
      if(Math.random() < 0.01) { // fire small bullets
        enemies.push({ x: boss.x + rand(-80,80), y: boss.y+60, r:8, vy: rand(200,300), hp:1, type:'bossbul' });
      }
    } else {
      boss.x = W/2 + Math.sin(boss.t*0.9)* (W*0.36);
      if(Math.random() < 0.02) { enemies.push({ x: boss.x, y: boss.y+80, r:12, vy: rand(240,340), hp:1, type:'bossbul' }); }
    }
    // bullet collisions on boss
    for(let bi=player.bullets.length-1; bi>=0; bi--){ const b=player.bullets[bi]; if(b.x>boss.x-120 && b.x<boss.x+120 && b.y>boss.y-80 && b.y<boss.y+80){ // hit
        player.bullets.splice(bi,1); boss.hp -= (b.type==='laser'?5:1); createExplosion(b.x,b.y); shake=10; if(b.type==='laser'){} }
    }
    if(boss.hp <= 0){ // boss down
      createExplosion(boss.x,boss.y); score += 2000; boss = null; document.getElementById('bossbar').style.display='none'; level++; }
  }}

  // spawn enemies gradually, and trigger bosses by level/time
  if(!boss && enemies.length < clamp(6,0,12) && Math.random() < 0.02) spawnEnemy();
  if(level === 1 && time > 25){ spawnBoss(1); level = 1.5; }
  if(level === 2 && time > 85){ spawnBoss(2); level = 2.5; }

  // power timer
  if(power.timer > 0){ power.timer -= dt; if(power.timer <= 0){ power.mode = 'single'; power.missileAmmo = 0; } }

  // update particles
  for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.x += p.vx*dt*60; p.y += p.vy*dt*60; p.alpha -= dt*1.2; if(p.alpha<=0) particles.splice(i,1); }

  // update UI
  document.getElementById('score').textContent = 'SCORE: ' + Math.floor(score);
  document.getElementById('lives').textContent = 'LIVES: ' + lives;
  // boss bar
  if(boss){ const pct = clamp(boss.hp / boss.maxHp * 100, 0, 100); document.getElementById('bossbarInner').style.width = pct + '%'; document.getElementById('bossbar').style.display='block'; }
  showPower();
}

// drawing
function draw(){ ctx.clearRect(0,0,W,H);
  // background gradient
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,`hsl(${(time*8)%360} 60% 6%)`); g.addColorStop(1,`hsl(${(time*8+80)%360} 70% 10%)`); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // starfield
  for(let i=0;i<60;i++){ const x=((i*97+time*40)%W); const y=(i*53)%H; ctx.fillStyle = `hsl(${(i*7+time*8)%360} 60% 55%)`; ctx.fillRect(x,y,2,2); }

  // screen shake
  if(shake>0){ ctx.save(); ctx.translate((Math.random()*2-1)*shake, (Math.random()*2-1)*shake); shake *= 0.92; }

  // powerups
  powerups.forEach(p=>{ const rad = 18 + Math.sin(time*8 + p.x)*3; ctx.save(); ctx.globalCompositeOperation='lighter'; const gr = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,rad); gr.addColorStop(0,'rgba(255,255,255,0.8)'); gr.addColorStop(1,'rgba(0,150,255,0.0)'); ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(p.x,p.y,rad,0,Math.PI*2); ctx.fill(); ctx.restore(); });

  // enemies
  enemies.forEach(e=>{ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='hsl(10 90% 60%)'; ctx.fillRect(e.x-e.r,e.y-e.r,e.r*2,e.r*2); ctx.restore(); });

  // boss
  if(boss){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle = boss.type==='alpha' ? '#ff7b7b' : '#ffb86b'; ctx.fillRect(boss.x-120,boss.y-60,240,120); ctx.restore(); }

  // player bullets
  player.bullets.forEach(b=>{
    if(b.type==='laser'){
      ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle = 'rgba(160,240,255,0.9)'; ctx.fillRect(b.x-6,0,12,b.y); ctx.restore();
    } else {
      ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(180,240,255,1)'; ctx.fillRect(b.x-4,b.y-14,8,18); ctx.restore();
    }
  });

  // particles
  particles.forEach(p=>{ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle = `hsla(${p.hue},100%,60%,${p.alpha})`; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.restore(); });

  // player
  ctx.save(); ctx.globalCompositeOperation='lighter'; const pb = ctx.createLinearGradient(player.x,player.y-player.r,player.x,player.y+player.r); pb.addColorStop(0,'#6ff'); pb.addColorStop(1,'#08f'); ctx.fillStyle = pb; roundShip(player.x,player.y,player.r*1.4,player.r*1.8); ctx.fill(); ctx.restore();

  if(shake>0) ctx.restore();
}

function roundShip(cx,cy,w,h){ ctx.beginPath(); ctx.moveTo(cx-w*0.3,cy-h*0.5); ctx.quadraticCurveTo(cx,cy-h*0.8,cx+w*0.3,cy-h*0.5); ctx.lineTo(cx+w*0.35,cy+h*0.3); ctx.quadraticCurveTo(cx,cy+h*0.55,cx-w*0.35,cy+h*0.3); ctx.closePath(); }

function createExplosion(x,y){ for(let i=0;i<18;i++){ particles.push({x:x+rand(-6,6), y:y+rand(-6,6), vx:rand(-120,120), vy:rand(-120,120), alpha:1, size:rand(2,6), hue:rand(0,360)}); } navigator.vibrate?.(80); }

// main loop
let last = performance.now(); function main(now){ const dt = Math.min((now-last)/1000, 0.033); last = now; update(dt); draw(); requestAnimationFrame(main); }
requestAnimationFrame(main);

// drop some initial enemies and powerups
for(let i=0;i<6;i++) spawnEnemy(); setTimeout(()=>{ for(let i=0;i<2;i++) spawnPower(rand(100,W-100), rand(150,H-300)); },2000);

// expose some debug control for browser
window.activatePower = activatePower; window.spawnBoss = spawnBoss;

</script>
</body>
</html>
