<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>飞机大战 · 五关终极版（触屏/排行榜/过场/分裂小怪）</title>
<style>
  :root{
    --ui: rgba(255,255,255,0.08);
    --ui-strong: rgba(255,255,255,0.14);
    --accent: #6ff;
  }
  html,body{height:100%;margin:0;background:#000;touch-action:none;-webkit-user-select:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Microsoft YaHei',sans-serif}
  #game{display:block;width:100vw;height:100vh}
  /* Joy */
  .joy-wrap{position:fixed;left:12px;bottom:12px;width:140px;height:140px;border-radius:999px;background:var(--ui);display:flex;align-items:center;justify-content:center;z-index:1000}
  .joy-base{position:relative;width:90%;height:90%;border-radius:999px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));}
  .joy-knob{position:absolute;width:46px;height:46px;border-radius:999px;background:linear-gradient(180deg,#08f,#0ff);box-shadow:0 6px 18px rgba(0,200,255,0.25);left:50%;top:50%;transform:translate(-50%,-50%)}
  /* Fire & aux */
  .fire-btn{position:fixed;right:14px;bottom:18px;width:86px;height:86px;border-radius:999px;background:radial-gradient(circle,#ffec6a,#ff6a6a);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:22px;z-index:1000;box-shadow:0 12px 24px rgba(255,100,100,0.18)}
  .aux-row{position:fixed;right:14px;bottom:120px;display:flex;flex-direction:column;gap:10px;z-index:1000}
  .aux{width:72px;height:42px;background:var(--ui);border-radius:999px;display:flex;align-items:center;justify-content:center;font-weight:600;user-select:none}
  /* HUD */
  .hud{position:fixed;left:12px;top:12px;z-index:1000;display:flex;gap:12px}
  .badge{background:var(--ui);padding:8px 12px;border-radius:999px}
  .power-ind{position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:1000}
  .bossbar{position:fixed;left:50%;top:52px;transform:translateX(-50%);width:80%;height:16px;background:rgba(255,255,255,0.06);border-radius:10px;overflow:hidden;z-index:1000}
  .bossbar-inner{height:100%;background:linear-gradient(90deg,#ff4d4d,#ffb347);width:0%}
  .level-title{position:fixed;left:50%;top:38%;transform:translate(-50%,-50%);z-index:1001;padding:12px 20px;border-radius:12px;background:rgba(0,0,0,0.6);font-weight:800;letter-spacing:2px;display:none;color:#fff;font-size:18px}
  /* Overlays */
  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;z-index:2000;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(0,0,0,0.8);color:#fff;padding:18px;border-radius:12px;min-width:260px;max-width:90%;text-align:center}
  .btn{display:inline-block;padding:10px 16px;border-radius:10px;background:var(--ui-strong);margin:8px 6px;color:#fff;font-weight:700;border:0;cursor:pointer}
  .hidden{display:none}
  .lb{max-height:60vh;overflow:auto;text-align:left}
  .lb-item{padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.03)}
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- HUD -->
<div class="hud">
  <div class="badge" id="score">SCORE: 0</div>
  <div class="badge" id="lives">LIVES: 5</div>
  <div class="badge" id="levelBadge">LEVEL: 1</div>
</div>
<div class="power-ind" id="powerIndicator"></div>
<div class="bossbar" id="bossbar" style="display:none"><div class="bossbar-inner" id="bossbarInner"></div></div>
<div class="level-title" id="levelTitle">LEVEL 1</div>

<!-- Controls -->
<div class="joy-wrap" id="joyWrap"><div class="joy-base" id="joyBase"><div class="joy-knob" id="joyKnob"></div></div></div>
<div class="fire-btn" id="fireBtn">FIRE</div>
<div class="aux-row">
  <div class="aux" id="btnSpread">散弹</div>
  <div class="aux" id="btnMissile">导弹</div>
</div>

<!-- Overlays: pause, continue, gameover, victory, leaderboard -->
<div class="overlay hidden" id="pauseOverlay">
  <div class="panel">
    <h2>PAUSED</h2>
    <div style="margin-top:8px">
      <button class="btn" id="resumeBtn">继续</button>
      <button class="btn" id="restartBtn">重开</button>
    </div>
  </div>
</div>

<div class="overlay hidden" id="continueOverlay">
  <div class="panel">
    <h2>继续？</h2>
    <p>消耗一条生命继续当前关卡</p>
    <div style="margin-top:8px">
      <button class="btn" id="doContinueBtn">继续（-1 生命）</button>
      <button class="btn" id="noContinueBtn">放弃</button>
    </div>
  </div>
</div>

<div class="overlay hidden" id="gameoverOverlay">
  <div class="panel">
    <h2>GAME OVER</h2>
    <p id="finalScoreText">得分: 0</p>
    <div style="margin-top:8px">
      <button class="btn" id="goRestartBtn">重开</button>
      <button class="btn" id="viewLbBtn">排行榜</button>
    </div>
  </div>
</div>

<div class="overlay hidden" id="victoryOverlay">
  <div class="panel">
    <h2>YOU WIN!</h2>
    <p id="victoryScoreText">得分: 0</p>
    <div style="margin-top:8px">
      <input id="playerName" placeholder="输入昵称保存排行榜" style="padding:8px;border-radius:8px;border:0;display:block;width:80%;margin:8px auto" />
      <button class="btn" id="saveScoreBtn">保存分数</button>
      <button class="btn" id="victoryRestartBtn">再来一局</button>
      <button class="btn" id="victoryLbBtn">排行榜</button>
    </div>
  </div>
</div>

<div class="overlay hidden" id="leaderboardOverlay">
  <div class="panel">
    <h2>排行榜（Top 10）</h2>
    <div class="lb" id="leaderboardList" style="margin:8px 0"></div>
    <div style="margin-top:8px">
      <button class="btn" id="lbCloseBtn">关闭</button>
      <button class="btn" id="lbClearBtn">清空</button>
    </div>
  </div>
</div>

<script>
/*
  飞机大战 — 五关完整版（修复：Boss击败后必有小怪；终极Boss触发胜利）
  - 保存为 UTF-8 无 BOM
  - 触屏左摇杆、右长按射击、散弹/镭射道具
  - 五个 Boss + Boss 登场过场台词
  - 第3关（T-Rex）被打败后：小怪分裂为追踪型小怪（更难）
  - 生命/继续/失败/胜利界面；排行榜（localStorage）
*/

// ------------------ Canvas & resize ------------------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth, H = canvas.height = innerHeight;
window.addEventListener('resize', ()=>{ W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

// ------------------ Game state ------------------
let score = 0;
let lives = 5;
let time = 0;
let level = 1;      // 1..5
let boss = null;    // boss object when present
let enemies = [], particles = [], powerups = [];
let shake = 0;
let playing = true;
let showLevelTimer = 0;
let gameOver = false;
let victory = false;

// ------------------ Player ------------------
const player = { x: W/2, y: H*0.78, r: 28, speed: 520, bullets: [], hp: 3 };

// ------------------ Power ------------------
let power = { mode:'single', timer:0, missileAmmo:0 };

// ------------------ Joystick ------------------
const joyBase = document.getElementById('joyBase');
const joyKnob = document.getElementById('joyKnob');
let joyActive = false, joyId = null, joyPos = { x:0, y:0 };
const maxJoy = 46;
function joyToVector(){ return { x: joyPos.x / maxJoy, y: joyPos.y / maxJoy }; }
function updateKnob(){ joyKnob.style.transform = `translate(${joyPos.x}px, ${joyPos.y}px)`; }

// ------------------ Controls: fire ------------------
let firing = false, fireInterval = null;
function startFiring(){ if(firing) return; firing = true; shoot(); fireInterval = setInterval(shoot, power.mode==='single'?180:(power.mode==='spread'?320:140)); }
function stopFiring(){ firing=false; if(fireInterval){ clearInterval(fireInterval); fireInterval=null; } }

function shoot(){
  if(power.mode === 'laser'){
    if(power.missileAmmo <= 0) return;
    power.missileAmmo--;
  }
  if(power.mode === 'single'){
    player.bullets.push({ x: player.x, y: player.y - player.r - 8, vx:0, vy:-1100, type:'bullet', t:0 });
  } else if(power.mode === 'spread'){
    const offs = [-0.32,-0.12,0,0.12,0.32];
    offs.forEach(o => player.bullets.push({ x:player.x + o*12, y:player.y - player.r - 8, vx:o*800, vy:-920, type:'bullet', t:0 }));
  } else if(power.mode === 'laser'){
    player.bullets.push({ x: player.x, y: player.y - player.r - 20, vx:0, vy:-1400, type:'laser', t:0 });
  }
}

// ------------------ Utility ------------------
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// ------------------ Spawning/enemies ------------------
function spawnEnemyVariant(){
  // more aggressive by level
  if(level === 1){
    enemies.push({ x:rand(40,W-40), y:-40, r:18, vy:rand(100,160), hp:1, pattern:'sine', t:0, wave:Math.random()*6.28 });
  } else if(level === 2){
    enemies.push({ x:rand(40,W-40), y:-40, r:20, vy:rand(140,220), hp:1, pattern:'dive', t:0, wave:Math.random()*6.28 });
  } else if(level === 3){
    enemies.push({ x:rand(40,W-40), y:-40, r:22, vy:rand(120,200), hp:2, pattern:'sine', t:0, wave:Math.random()*6.28 });
  } else if(level === 4){
    enemies.push({ x:rand(40,W-40), y:-40, r:20, vy:rand(120,200), hp:2, pattern:'shooter', t:0, wave:Math.random()*6.28, shootCooldown:rand(0.6,1.6) });
  } else {
    enemies.push({ x:rand(40,W-40), y:-40, r:16, vy:rand(160,280), hp:1, pattern:'zigzag', t:0, wave:Math.random()*6.28 });
  }
}

function spawnPower(x,y){
  const t = Math.random()<0.5 ? 'spread' : 'laser';
  powerups.push({ x,y,r:18,type:t,ttl:9 });
}

// ------------------ Boss defs ------------------
const BOSS_DEFS = [
  { id:1, name:'Alien', type:'alien', hp:80, color:'#a2ffb8', behavior:'alpha', quote:'你不属于这里…' },
  { id:2, name:'Pteranodon', type:'ptera', hp:120, color:'#9be0ff', behavior:'ptera', quote:'俯冲，猎物…' },
  { id:3, name:'T-Rex', type:'trex', hp:180, color:'#ffb4a2', behavior:'trex', quote:'咆哮！你来了。' },
  { id:4, name:'MechaDino', type:'mech', hp:240, color:'#ffd66b', behavior:'mech', quote:'系统：战斗模式启动。' },
  { id:5, name:'Overlord', type:'overlord', hp:400, color:'#ffa0ff', behavior:'overlord', quote:'终极主宰降临。' },
];

function spawnBossByLevel(lv){
  const def = BOSS_DEFS[lv-1];
  if(!def) return;
  boss = { ...def, hp:def.hp, maxHp:def.hp, x:W/2, y:-260, t:0, phase:0 };
  document.getElementById('bossbar').style.display = 'block';
  playBossIntro(def.name, def.quote);
  document.getElementById('levelBadge').textContent = 'BOSS: ' + def.name;
}

// ------------------ Boss Intro (动画+台词) ------------------
const levelTitleEl = document.getElementById('levelTitle');
function playBossIntro(name, quote){
  levelTitleEl.textContent = name + ' — ' + quote;
  levelTitleEl.style.display = 'block';
  levelTitleEl.style.opacity = '0';
  levelTitleEl.style.transform = 'translate(-50%,-60%) scale(0.9)';
  levelTitleEl.animate([
    { transform:'translate(-50%,-60%) scale(0.9)', opacity:0 },
    { transform:'translate(-50%,-50%) scale(1.06)', opacity:1 },
    { transform:'translate(-50%,-50%) scale(1.0)', opacity:1 }
  ], { duration:900, easing:'cubic-bezier(.22,.9,.39,1)' });
  setTimeout(()=> levelTitleEl.style.display='none', 1600);
}

// ------------------ Joy handlers ------------------
joyBase.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  joyActive = true; joyId = t.identifier;
  handleJoyFromTouch(t);
});
joyBase.addEventListener('touchmove', e => {
  e.preventDefault();
  if(!joyActive) return;
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    if(t.identifier === joyId){ handleJoyFromTouch(t); break; }
  }
});
joyBase.addEventListener('touchend', e => {
  for(let i=0;i<e.changedTouches.length;i++){
    if(e.changedTouches[i].identifier === joyId){
      joyActive=false; joyId=null; joyPos.x=0; joyPos.y=0; updateKnob(); break;
    }
  }
});
function handleJoyFromTouch(t){
  const rect = joyBase.getBoundingClientRect();
  const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
  let dx = (t.clientX - cx), dy = (t.clientY - cy);
  const dist = Math.hypot(dx,dy);
  const max = (rect.width/2) - 12;
  if(dist > max){ dx = dx*(max/dist); dy = dy*(max/dist); }
  joyPos.x = dx; joyPos.y = dy; updateKnob();
}

// ------------------ Fire & aux button bindings ------------------
const fireBtn = document.getElementById('fireBtn');
fireBtn.addEventListener('touchstart', e => { e.preventDefault(); startFiring(); });
fireBtn.addEventListener('touchend', e => { e.preventDefault(); stopFiring(); });
fireBtn.addEventListener('mousedown', e => { e.preventDefault(); startFiring(); });
fireBtn.addEventListener('mouseup', e => { e.preventDefault(); stopFiring(); });

document.getElementById('btnSpread').addEventListener('click', ()=> activatePower('spread',12));
document.getElementById('btnMissile').addEventListener('click', ()=> activatePower('laser',18,4));

function activatePower(mode, seconds, ammo){
  power.mode = mode; power.timer = seconds; if(ammo) power.missileAmmo = ammo; updatePowerUI();
}
function updatePowerUI(){
  const el = document.getElementById('powerIndicator');
  if(power.mode === 'single' || power.timer <= 0) el.innerHTML = '';
  else el.innerHTML = `<div style="padding:6px 12px;background:var(--ui);border-radius:999px;font-weight:700">${power.mode.toUpperCase()} ${power.mode==='laser'?(' x'+power.missileAmmo):''}</div>`;
}

// ------------------ Particles & explosions ------------------
function createExplosion(x,y, count=18){
  for(let i=0;i<count;i++){
    particles.push({ x:x+rand(-8,8), y:y+rand(-8,8), vx:rand(-220,220), vy:rand(-220,220), alpha:1, size:rand(2,6), hue:rand(0,360) });
  }
  try{ navigator.vibrate && navigator.vibrate(60); }catch(e){}
}

// ------------------ Level advance & post-boss changes ------------------
function advanceLevel(){
  // Called when a boss is defeated.
  // Implement per-level small-enemy behavioral changes.
  if(level === 1){
    // After Alien: slight increase (handled via spawn counts)
  } else if(level === 2){
    // After Pteranodon: make some existing enemies dive
    enemies.forEach(e => { if(Math.random()<0.4) e.pattern='dive'; });
  } else if(level === 3){
    // After T-Rex: remaining small enemies split into 'tracker' homing enemies
    const trackers = [];
    enemies.forEach(e => {
      trackers.push({ x:e.x, y:e.y, r:10, vy:0, hp:1, pattern:'tracker', t:0 });
      trackers.push({ x:e.x+rand(-12,12), y:e.y, r:10, vy:0, hp:1, pattern:'tracker', t:0 });
    });
    enemies = enemies.concat(trackers);
  } else if(level === 4){
    // After MechaDino: shooters fire more often
    enemies.forEach(e => { if(e.pattern==='shooter') e.shootCooldown = Math.max(0.2, e.shootCooldown*0.7); });
  }
  // advance
  level = Math.min(level+1, 5);
  time = 0; // reset timer for next boss trigger
  document.getElementById('levelBadge').textContent = 'LEVEL: ' + level;
  showLevelTitle('LEVEL ' + level);
  // spawn a bunch of enemies immediately so field isn't empty
  for(let i=0;i<6 + level;i++) spawnEnemyVariant();
}

// ------------------ Draw helpers for Boss (vector shapes) ------------------
function drawAlienBoss(x,y, c){
  ctx.beginPath(); ctx.ellipse(x,y,120,70,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.beginPath(); ctx.arc(x-36,y-6,10,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x+36,y-6,10,0,Math.PI*2); ctx.fill();
}
function drawPteraBoss(x,y){ ctx.beginPath(); ctx.moveTo(x-140,y); ctx.quadraticCurveTo(x-20,y-40,x,y-10); ctx.quadraticCurveTo(x+20,y-40,x+140,y); ctx.lineTo(x+40,y+40); ctx.lineTo(x-40,y+40); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.arc(x,y-6,26,0,Math.PI*2); ctx.fill(); }
function drawTrexBoss(x,y){ ctx.beginPath(); ctx.moveTo(x-120,y+30); ctx.quadraticCurveTo(x-60,y-120,x+20,y-40); ctx.quadraticCurveTo(x+80,y-10,x+120,y+30); ctx.lineTo(x+60,y+60); ctx.lineTo(x-60,y+60); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.arc(x-20,y-30,16,0,Math.PI*2); ctx.fill(); }
function drawMechaBoss(x,y){ ctx.fillRect(x-140,y-40,280,80); ctx.fillStyle='rgba(0,0,0,0.14)'; ctx.fillRect(x-120,y-20,60,40); ctx.fillRect(x+60,y-20,60,40); }
function drawOverlordBoss(x,y){ ctx.beginPath(); ctx.ellipse(x,y,160,90,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(x,y+30,120,50,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x,y-40,28,0,Math.PI*2); ctx.fill(); }

// ------------------ Update loop ------------------
function update(dt){
  if(!playing) return;
  time += dt;

  // move player via joystick
  const v = joyToVector();
  player.x += v.x * player.speed * dt;
  player.y += v.y * player.speed * dt;
  player.x = clamp(player.x, 40, W-40); player.y = clamp(player.y, H*0.45, H-40);

  // bullets update
  for(let i=player.bullets.length-1;i>=0;i--){
    const b = player.bullets[i]; b.x += (b.vx||0)*dt; b.y += (b.vy||0)*dt; b.t = (b.t||0) + dt;
    if(b.y < -80 || b.x < -200 || b.x > W+200) player.bullets.splice(i,1);
  }

  // enemies update
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    e.t = (e.t||0) + dt;
    if(e.pattern === 'sine'){ e.y += e.vy*dt; e.x += Math.sin(e.t*2 + (e.wave||0))*40*dt; }
    else if(e.pattern === 'dive'){ e.y += e.vy*dt; if(Math.random() < 0.002) e.vy += 80; }
    else if(e.pattern === 'zigzag'){ e.y += e.vy*dt; e.x += Math.sin(e.t*6)*80*dt; }
    else if(e.pattern === 'shooter'){ e.y += e.vy*dt; e.since = (e.since||0) + dt; if(e.since > (e.shootCooldown||1)){ e.since = 0; enemies.push({ x:e.x, y:e.y+12, r:6, vy:rand(260,380), hp:1, pattern:'bullet', t:0 }); } }
    else if(e.pattern === 'tracker'){
      const dx = player.x - e.x; const dy = player.y - e.y; const d = Math.hypot(dx,dy) || 1;
      e.x += (dx/d) * 160 * dt; e.y += (dy/d) * 160 * dt;
    }
    if(e.y > H + 180) enemies.splice(i,1);
  }

  // powerup pickup
  for(let i=powerups.length-1;i>=0;i--){
    const p = powerups[i]; p.ttl -= dt;
    if(p.ttl <= 0) { powerups.splice(i,1); continue; }
    if(Math.hypot(p.x-player.x,p.y-player.y) < p.r + player.r){
      activatePower(p.type, p.type==='spread'?12:16, p.type==='laser'?3:0);
      powerups.splice(i,1);
    }
  }

  // bullets vs enemies
  for(let ei=enemies.length-1; ei>=0; ei--){
    const e = enemies[ei];
    for(let bi=player.bullets.length-1; bi>=0; bi--){
      const b = player.bullets[bi];
      if(b.x > e.x - e.r && b.x < e.x + e.r && b.y > e.y - e.r && b.y < e.y + e.r){
        player.bullets.splice(bi,1);
        e.hp = (e.hp||1) - (b.type === 'laser' ? 3 : 1);
        createExplosion(e.x, e.y, 8);
        if(e.hp <= 0){
          if(Math.random() < 0.12) spawnPower(e.x, e.y);
          enemies.splice(ei,1);
          score += (level*10 + 40);
        }
        break;
      }
    }
  }

  // bullets vs boss
  if(boss){
    boss.t += dt;
    if(boss.y < 80) boss.y += 40*dt;
    else {
      if(boss.behavior === 'alpha'){
        boss.x = W/2 + Math.sin(boss.t*0.6)*(W*0.22);
        if(Math.random() < 0.015) enemies.push({ x:boss.x + rand(-80,80), y:boss.y+60, r:10, vy:rand(220,340), hp:1, pattern:'bullet', t:0 });
      } else if(boss.behavior === 'ptera'){
        boss.x = W/2 + Math.sin(boss.t*0.9)*(W*0.36);
        if(Math.random() < 0.02){ for(let i=0;i<3;i++) enemies.push({ x:boss.x + i*40 - 40, y:boss.y+60, r:16, vy:rand(300,420), hp:1, pattern:'dive' }); }
      } else if(boss.behavior === 'trex'){
        boss.x = W/2 + Math.cos(boss.t*0.5)*(W*0.15);
        if(Math.random() < 0.03){ for(let i=0;i<6;i++) enemies.push({ x:boss.x + rand(-140,140), y:boss.y+40, r:12, vy: rand(200,360), hp:1, pattern:'zigzag' }); }
      } else if(boss.behavior === 'mech'){
        boss.x = W/2 + Math.sin(boss.t*0.7)*(W*0.28);
        if(Math.random() < 0.04) enemies.push({ x:boss.x + rand(-60,60), y:boss.y+80, r:14, vy: rand(280,420), hp:1, pattern:'shooter', shootCooldown: rand(0.4,1.2) });
      } else if(boss.behavior === 'overlord'){
        boss.x = W/2 + Math.sin(boss.t*1.1)*(W*0.36);
        if(Math.random() < 0.06){ for(let a=0;a<8;a++) enemies.push({ x:boss.x + rand(-200,200), y:boss.y+40, r:10, vy:rand(300,520), hp:1, pattern:'bullet' }); }
      }

      for(let bi=player.bullets.length-1; bi>=0; bi--){
        const b = player.bullets[bi];
        if(b.x > boss.x - 120 && b.x < boss.x + 120 && b.y > boss.y - 80 && b.y < boss.y + 80){
          player.bullets.splice(bi,1);
          boss.hp -= (b.type === 'laser' ? 6 : 1);
          createExplosion(b.x,b.y,6); shake = 10;
        }
      }

      if(boss.hp <= 0){
        const bossType = boss.type; // capture type before clearing
        createExplosion(boss.x,boss.y,36);
        score += 2000 + level*500;
        if(bossType === 'trex'){
          // spawn many trackers immediately
          for(let i=0;i<18;i++){
            enemies.push({ x: rand(60,W-60), y: rand(60, H*0.4), r:10, vy:0, hp:1, pattern:'tracker', t:0 });
          }
        }
        boss = null;
        document.getElementById('bossbar').style.display = 'none';
        // If this was the final boss -> victory, otherwise advance
        if(bossType === 'overlord' || level >= 5){
          triggerVictory();
        } else {
          advanceLevel();
        }
      }
    }
  }

  // ambient spawn
  if(!boss){
    const cap = clamp(5 + level*2, 4, 20);
    if(enemies.length < cap && Math.random() < 0.028 + level*0.003) spawnEnemyVariant();
  }

  // spawn boss triggers (time thresholds)
  if(!boss){
    if(level === 1 && time > 18) { spawnBossByLevel(1); time = 0; }
    else if(level === 2 && time > 38) { spawnBossByLevel(2); time = 0; }
    else if(level === 3 && time > 70) { spawnBossByLevel(3); time = 0; }
    else if(level === 4 && time > 110) { spawnBossByLevel(4); time = 0; }
    else if(level === 5 && time > 160) { spawnBossByLevel(5); time = 0; }
  }

  // power timer
  if(power.timer > 0){
    power.timer -= dt; if(power.timer <= 0){ power.mode='single'; power.missileAmmo=0; updatePowerUI(); }
  }

  // particles update
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i]; p.x += p.vx*dt; p.y += p.vy*dt; p.alpha -= dt*1.2; if(p.alpha <= 0) particles.splice(i,1);
  }

  // update UI
  document.getElementById('score').textContent = 'SCORE: ' + Math.floor(score);
  document.getElementById('lives').textContent = 'LIVES: ' + lives;
  document.getElementById('levelBadge').textContent = 'LEVEL: ' + level;
  if(boss){ const pct = clamp(boss.hp / boss.maxHp * 100, 0, 100); document.getElementById('bossbarInner').style.width = pct + '%'; document.getElementById('bossbar').style.display='block'; }
  updatePowerUI();
}

// ------------------ Draw loop ------------------
function draw(){
  ctx.clearRect(0,0,W,H);
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,`hsl(${(time*8)%360} 60% 6%)`); g.addColorStop(1,`hsl(${(time*8+80)%360} 70% 10%)`); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  for(let i=0;i<60;i++){ const x = ((i*97 + time*40)%W); const y = (i*53)%H; ctx.fillStyle = `hsl(${(i*7 + time*8)%360} 60% 55%)`; ctx.fillRect(x,y,2,2); }
  if(shake > 0){ ctx.save(); ctx.translate((Math.random()*2-1)*shake, (Math.random()*2-1)*shake); shake *= 0.92; }
  powerups.forEach(p => { const rad = 18 + Math.sin(time*8 + p.x)*3; ctx.save(); ctx.globalCompositeOperation = 'lighter'; const gr = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,rad); gr.addColorStop(0,'rgba(255,255,255,0.9)'); gr.addColorStop(1,'rgba(0,150,255,0)'); ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(p.x,p.y,rad,0,Math.PI*2); ctx.fill(); ctx.restore(); });
  enemies.forEach(e => { ctx.save(); ctx.globalCompositeOperation='lighter'; if(e.pattern === 'tracker') ctx.fillStyle='hsl(280 80% 60%)'; else if(level <= 2) ctx.fillStyle='hsl(10 90% 60%)'; else if(level === 3) ctx.fillStyle='hsl(24 90% 60%)'; else if(level === 4) ctx.fillStyle='hsl(200 90% 60%)'; else ctx.fillStyle='hsl(280 80% 60%)'; if(e.pattern === 'sine' || e.pattern === 'dive' || e.pattern === 'zigzag' || e.pattern === 'tracker'){ ctx.fillRect(e.x - e.r, e.y - e.r, e.r*2, e.r*2); } else { ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill(); } ctx.restore(); });
  if(boss){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle = boss.color; if(boss.type === 'alien') drawAlienBoss(boss.x,boss.y); else if(boss.type === 'ptera') drawPteraBoss(boss.x,boss.y); else if(boss.type === 'trex') drawTrexBoss(boss.x,boss.y); else if(boss.type === 'mech') drawMechaBoss(boss.x,boss.y); else drawOverlordBoss(boss.x,boss.y); ctx.restore(); }
  player.bullets.forEach(b => { if(b.type === 'laser'){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(160,240,255,0.9)'; ctx.fillRect(b.x - 6, 0, 12, b.y); ctx.restore(); } else { ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(180,240,255,1)'; ctx.fillRect(b.x-4,b.y-16,8,20); ctx.restore(); } });
  particles.forEach(p => { ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.fillStyle = `hsla(${p.hue},100%,60%,${p.alpha})`; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.restore(); });
  ctx.save(); ctx.globalCompositeOperation='lighter'; const pb = ctx.createLinearGradient(player.x,player.y-player.r,player.x,player.y+player.r); pb.addColorStop(0,'#6ff'); pb.addColorStop(1,'#08f'); ctx.fillStyle = pb; roundShip(player.x,player.y,player.r*1.4,player.r*1.8); ctx.fill(); ctx.restore();
  if(shake > 0) ctx.restore();
}

// ------------------ Drawing helpers ------------------
function roundShip(cx,cy,w,h){ ctx.beginPath(); ctx.moveTo(cx-w*0.3,cy-h*0.5); ctx.quadraticCurveTo(cx,cy-h*0.8,cx+w*0.3,cy-h*0.5); ctx.lineTo(cx+w*0.35,cy+h*0.3); ctx.quadraticCurveTo(cx,cy+h*0.55,cx-w*0.35,cy+h*0.3); ctx.closePath(); }
function drawAlienBoss(x,y){ ctx.beginPath(); ctx.ellipse(x,y,120,70,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.beginPath(); ctx.arc(x-36,y-6,10,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x+36,y-6,10,0,Math.PI*2); ctx.fill(); }
function drawPteraBoss(x,y){ ctx.beginPath(); ctx.moveTo(x-140,y); ctx.quadraticCurveTo(x-20,y-40,x,y-10); ctx.quadraticCurveTo(x+20,y-40,x+140,y); ctx.lineTo(x+40,y+40); ctx.lineTo(x-40,y+40); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.arc(x,y-6,26,0,Math.PI*2); ctx.fill(); }
function drawTrexBoss(x,y){ ctx.beginPath(); ctx.moveTo(x-120,y+30); ctx.quadraticCurveTo(x-60,y-120,x+20,y-40); ctx.quadraticCurveTo(x+80,y-10,x+120,y+30); ctx.lineTo(x+60,y+60); ctx.lineTo(x-60,y+60); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.arc(x-20,y-30,16,0,Math.PI*2); ctx.fill(); }
function drawMechaBoss(x,y){ ctx.fillRect(x-140,y-40,280,80); ctx.fillStyle='rgba(0,0,0,0.14)'; ctx.fillRect(x-120,y-20,60,40); ctx.fillRect(x+60,y-20,60,40); }
function drawOverlordBoss(x,y){ ctx.beginPath(); ctx.ellipse(x,y,160,90,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(x,y+30,120,50,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x,y-40,28,0,Math.PI*2); ctx.fill(); }

// ------------------ Main loop ------------------
let last = performance.now();
function main(now){
  const dt = Math.min((now - last) / 1000, 0.033);
  last = now;
  if(!gameOver && !victory){
    update(dt);
    draw();
  }
  requestAnimationFrame(main);
}
requestAnimationFrame(main);

// ------------------ Init ------------------
for(let i=0;i<6;i++) spawnEnemyVariant();
setTimeout(()=>{ for(let i=0;i<2;i++) spawnPower(rand(100,W-100), rand(150,H-300)); }, 1200);

// ------------------ Debug hooks ------------------
window.spawnBoss = spawnBossByLevel;
window.activatePower = activatePower;

// ------------------ Pause / overlays / continue / gameover / victory ------------------
const pauseOverlay = document.getElementById('pauseOverlay');
const resumeBtn = document.getElementById('resumeBtn');
const restartBtn = document.getElementById('restartBtn');
resumeBtn.addEventListener('click', ()=>{ hideOverlay('pauseOverlay'); playing=true; });
restartBtn.addEventListener('click', ()=>{ hideAllOverlays(); restartGame(); });

function showOverlay(id){ document.getElementById(id).classList.remove('hidden'); }
function hideOverlay(id){ document.getElementById(id).classList.add('hidden'); }
function hideAllOverlays(){ document.querySelectorAll('.overlay').forEach(el => el.classList.add('hidden')); }

const continueOverlay = document.getElementById('continueOverlay');
const doContinueBtn = document.getElementById('doContinueBtn');
const noContinueBtn = document.getElementById('noContinueBtn');
doContinueBtn.addEventListener('click', ()=> {
  if(lives > 0){ lives--; hideOverlay('continueOverlay'); playing=true; player.x = W/2; player.y = H*0.78; enemies = []; for(let i=0;i<6;i++) spawnEnemyVariant(); }
});
noContinueBtn.addEventListener('click', ()=> { hideOverlay('continueOverlay'); triggerGameOver(); });

const gameoverOverlay = document.getElementById('gameoverOverlay');
const goRestartBtn = document.getElementById('goRestartBtn');
const viewLbBtn = document.getElementById('viewLbBtn');
goRestartBtn.addEventListener('click', ()=>{ hideAllOverlays(); restartGame(); });
viewLbBtn.addEventListener('click', ()=>{ renderLeaderboard(); });

const victoryOverlay = document.getElementById('victoryOverlay');
const victoryScoreText = document.getElementById('victoryScoreText');
const saveScoreBtn = document.getElementById('saveScoreBtn');
const playerNameInput = document.getElementById('playerName');
const victoryRestartBtn = document.getElementById('victoryRestartBtn');
const victoryLbBtn = document.getElementById('victoryLbBtn');

saveScoreBtn.addEventListener('click', ()=> {
  const name = (playerNameInput.value || 'Player').slice(0,20);
  if(name.trim() === '') return;
  saveScoreToLeaderboard(name, Math.floor(score));
  renderLeaderboard();
});
victoryRestartBtn.addEventListener('click', ()=>{ hideAllOverlays(); restartGame(); });
victoryLbBtn.addEventListener('click', ()=>{ renderLeaderboard(); });

// ------------------ Leaderboard ------------------
const leaderboardList = document.getElementById('leaderboardList');
const lbCloseBtn = document.getElementById('lbCloseBtn');
const lbClearBtn = document.getElementById('lbClearBtn');
lbCloseBtn.addEventListener('click', ()=> hideAllOverlays());
lbClearBtn.addEventListener('click', ()=> { localStorage.removeItem('feijidazhan_leaderboard'); renderLeaderboard(); });

function loadLeaderboard(){ try{ const raw = localStorage.getItem('feijidazhan_leaderboard'); if(!raw) return []; const arr = JSON.parse(raw); return Array.isArray(arr)?arr:[]; }catch(e){return[];} }
function saveLeaderboard(arr){ localStorage.setItem('feijidazhan_leaderboard', JSON.stringify(arr)); }
function saveScoreToLeaderboard(name, sc){
  const arr = loadLeaderboard();
  arr.push({ name: name, score: sc, date: new Date().toISOString() });
  arr.sort((a,b)=> b.score - a.score);
  saveLeaderboard(arr.slice(0, 50));
}
function renderLeaderboard(){
  const arr = loadLeaderboard();
  leaderboardList.innerHTML = '';
  if(arr.length === 0){ leaderboardList.innerHTML = '<div style="padding:8px;col
